getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
c <- x$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- x$get()
c <- solve(x)
x$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x_list <- makeCacheMatrix(x)
x_list
x_list$set()
x_list$getsolve()
cacheSolve(x_list)
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, x_list) {
c <- x_list$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- x_list$get()
c <- solve(x)
x_list$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x <- cacheSolve(x, makeCacheMatrix(x))
x
x <- matrix(1:4, 2, 2)
x_inverted <- cacheSolve(x, makeCacheMatrix(x))
x
x_inverted
x_inverted <- cacheSolve(x, makeCacheMatrix(x))
x
x_inverted
x_inverted <- cacheSolve(x, makeCacheMatrix(x))
x_inverted <- cacheSolve(x, makeCacheMatrix(x))
x_inverted <- cacheSolve(x, makeCacheMatrix(x))
x <- matrix(1:4, 2, 2)
x_inverted <- cacheSolve(x, makeCacheMatrix(x))
x <- matrix(1:4, 2, 2)
makeCacheMatrix(x)
makeCacheMatrix(x)
x_list <- makeCacheMatrix(x)
x_list
x <- cacheSolve(x, makeCacheMatrix(x))
x <- cacheSolve(x, makeCacheMatrix(x))
x <- cacheSolve(x, makeCacheMatrix(x))
x_list <- makeCacheMatrix(x)
x_list
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, x_list) {
c <- x_list$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- x_list$get()
c <- solve(x)
x_list$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x_list <- makeCacheMatrix(x)
x_list
x <- cacheSolve(x, makeCacheMatrix(x))
x_list <- makeCacheMatrix(x)
x_list
x_list$getsolve()
rm(list = ls())
## The following functions make invert of matrix.
## First function calculates special object created with the makeCacheMatrix function.
## It first checks to see if the invert has already been done.
## If so, it gets inverted matrix from the cache and skips the computation.
## Otherwise, it maks the invert of the matrix and sets it via the setmean function.
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, x_list) {
c <- x_list$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- x_list$get()
c <- solve(x)
x_list$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x_list <- makeCacheMatrix(x)
x <- cacheSolve(x, makeCacheMatrix(x))
x_list
x_list <- makeCacheMatrix(x)
x_list
rm(list = ls())
x <- matrix(1:4, 2, 2)
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
xl <- list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
c <- xl$getsolve()
c <- xl$getsolve()
xl
c <- xl$getsolve
if(!is.null(c)) {
message("getting cached data")
return(c)
}
is.null(c)
!is.null(c)
message("getting cached data")
return(c)
data <- xl$get()
c <- solve(x)
xl$setsolve(c)
c
c <- xl$getsolve
if(!is.null(c)) {
message("getting cached data")
return(c)
}
c <- xl$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- xl$get()
c <- solve(x)
xl$setsolve(c)
c
return(c)
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, xl) {
c <- xl$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- xl$get()
c <- solve(x)
xl$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x <- cacheSolve(x, makeCacheMatrix(x))
x <- cacheSolve(x, makeCacheMatrix(x))
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, xl) {
c <- xl$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- xl$get()
c <- solve(x)
xl$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
makeCacheMatrix(x)
!is.null(makeCacheMatrix(x))
!is.null(makeCacheMatrix(x)$getsolve())
!is.null(makeCacheMatrix(x)$getsolve())
x <- cacheSolve(x, makeCacheMatrix(x))
!is.null(makeCacheMatrix(x)$getsolve())
rm(list = ls())
## The following functions make invert of matrix.
## First function calculates special object created with the makeCacheMatrix function.
## It first checks to see if the invert has already been done.
## If so, it gets inverted matrix from the cache and skips the computation.
## Otherwise, it maks the invert of the matrix and sets it via the setmean function.
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, xl) {
c <- xl$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- xl$get()
c <- solve(data)
xl$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x <- cacheSolve(x, makeCacheMatrix(x))
x <- cacheSolve(x, makeCacheMatrix(x))
rm(list = ls())
## The following functions make invert of matrix.
## First function calculates special object created with the makeCacheMatrix function.
## It first checks to see if the invert has already been done.
## If so, it gets inverted matrix from the cache and skips the computation.
## Otherwise, it maks the invert of the matrix and sets it via the setmean function.
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
c <- x$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- x$get()
c <- solve(data, ...)
x$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
makeCacheMatrix(x)
x <- cacheSolve(x, makeCacheMatrix(x))
x <- cacheSolve(makeCacheMatrix(x))
x <- cacheSolve(makeCacheMatrix(x))
x <- cacheSolve(makeCacheMatrix(x))
x
x <- matrix(1:4, 2, 2)
x <- matrix(1:4, 2, 2)
x <- cacheSolve(makeCacheMatrix(x))
x <- matrix(1:4, 2, 2)
x <- cacheSolve(makeCacheMatrix(x))
x
x <- matrix(1:4, 2, 2)
x
x <- cacheSolve(makeCacheMatrix(x))
x
x <- matrix(1:4, 2, 2)
makeCacheMatrix(x)
x$getsolve()
makeCacheMatrix(x)$getsolve()
x <- cacheSolve(makeCacheMatrix(x))
makeCacheMatrix(x)$getsolve()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
c <- NULL
set <- function(y) {
x <<- y
c <<- NULL
}
get <- function() x
setsolve <- function(solve) c <<- solve
getsolve <- function() c
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
c <- x$getsolve()
if(!is.null(c)) {
message("getting cached data")
return(c)
}
data <- x$get()
c <- solve(data, ...)
x$setsolve(c)
c
}
x <- matrix(1:4, 2, 2)
x <- cacheSolve(makeCacheMatrix(x))
c <- x$getsolve()
makeCacheMatrix(x)$getsolve()
rm(list = ls())
makeCacheMatrix <- function(x = matrix()) {
cachedInv <- NULL ## initialize inverse
## set x in parent env with the desired value, if inverse is already set, get rid of it!
set <- function(userValue = matrix()) {
x <<- userValue
cachedInv <<- NULL
}
get <- function() x
##set inverse variable in parent env to desired value and return the value as a convenience
setInverse <- function(invVal) {
cachedInv <<- invVal
return(cachedInv)
}
getInverse  <- function() cachedInv
list(set=set, get=get, setInverse=setInverse, getInverse=getInverse)
}
cacheSolve <- function(x=makeCacheMatrix(1:4, nrow=2, ncol=2), ...) { ##special matrix provided or create a test 2x2 matrix
## let's see if there's something there already
calculatedInverse <- x$getInverse()
##check if there's a cached value AND it's a matrix
if(!is.null(calculatedInverse) && is.matrix(calculatedInverse)) {
message("We found cached data and saved valuable cpus!!!")
return(calculatedInverse)
}
## otherwise get the matrix
matrixToSolve <- x$get()
## try to solve the matrix and catch errors and warnings
calculatedInverse <- tryCatch({
solve(matrixToSolve)
}, warning=function(w) {
message("This may not be the result you're looking for")
message(w)
}, error=function(e) {
message("Something went wrong solving your matrix")
message(e)
message("\n")
})
## whatever the case, set the value of the inverse (NULL if something went wrong)
message("Setting the value of inverse to:")
x$setInverse(calculatedInverse)
}
cacheSolve()
makeCacheMatrix(x)
cacheSolve(makeCacheMatrix(x))
x = matrix(1:4, 2, 2)
cacheSolve(makeCacheMatrix(x))
cacheSolve(makeCacheMatrix(x))
cacheSolve(makeCacheMatrix(x))
setwd("/Users/slechwar/Google_Drive/04_Dev/Inne/R courses/Coursea")
rm(list = ls())
x <- c(1,2,3,4,4,4,4,5,5)
str(x)
summary(x)
str(lm)
set.seed(1)
x <- rnorm(100)
e <- rnorm(100, 0, 2)
y <- 0.5 + 2*x + e
summary(y)
plot(x, y)
system.time(readLines("http://www.jhsph.edu"))
set.seed(1)
rpois(5, 2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
x
y
plot(x, y)
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
Rprof()
summaryRprof()
library(swirl)
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(plants)
head(plants)
head(plants, 10)
tail(plants, 15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6, 4 replace = TRUE)
sample(1:6, 4 replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:20, 10, replace = FALSE)
sample(1:20, 10)
LETTERS
sample(LETTERS)
flips <- sample(c(0,1), 100, prob = c(0.3, 0.7))
flips <- sample(c(0,1), 100, prob = c(0.3, 0.7), replace = TRUE)
flips
sum(flips)
?rrbinom
?rbinom
rbinom(1, size = 100, prob = 0.7)
flips2 <- rbinom(c(0, 1), size = 100, prob = 0.7)
rbinom(100, size = 1, prob = 0.7)
flips2 <- rbinom(100, size = 1, prob = 0.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10, 100, 25)
pnorm(5)
pnorm(5, 10)
rpois(5, 10)
replicate(100, rpois(5, 10))
my_pois <- replicate(100, rpois(5, 10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
data("cars")
data(cars)
?cars
head(cars)
plot(cars)
?plot
plot(x = cars$dist, y = cars$speed)
plot(x = cars$speed, y = cars$dist)
plot(x = cars$dist, y = cars$speed)
plot(x = cars$speed, y = cars$dist)
plot(x = cars$speed, y = cars$dist)
plot(x = cars$dist, y = cars$speed)
plot(x = cars$speed, y = cars$dist, xlab = "Speed")
plot(x = cars$speed, y = cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, xlab = "Speed", ylab = "Stopping Distance", main = "My Plot")
plot(x = cars$speed, y = cars$dist, main = "My Plot")
plot(cars, main = "My Plot")
plot(cars, main = "My Plot Subtitle")
plot(cars, sub = "My Plot Subtitle")
plot(cars, col = 2)
plot(cars, xlim = c(10, 15))
plot(cars, pch = 2)
data("mtcars")
data(mtcars)
?boxplot
boxplot(formula = mpg ~ cyl, data = mtcars)
hist(mtcars$mpg)
